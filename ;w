use codecrafters_http_server::ThreadPool;
use serde::{Deserialize, Serialize};
use serde_json;
use std::{
    collections::HashMap,
    env, fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
    path::Path,
    sync::Arc,
};

fn main() {
    println!("Logs from your program will appear here!");

    let args: Vec<String> = env::args().collect();
    let dir = parse_args(args);
    let dir = Arc::new(dir);

    let listener = TcpListener::bind("127.0.0.1:4221").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        match stream {
            Ok(stream) => {
                println!("accepted new connection");
                let dir = Arc::clone(&dir);
                pool.execute(move || {
                    handle_connection(stream, dir);
                });
            }
            Err(e) => {
                println!("error: {}", e);
            }
        }
    }
}

fn handle_connection(mut stream: TcpStream, dir: Arc<String>) {
    let mut buf_reader = BufReader::new(&stream);
    let request = buf_reader.fill_buf().unwrap();
    let length = request.len();

    let mut request = parse_request(request);
    let status = request.parse_endpoint(&dir);

    buf_reader.consume(length);

    let response = format!(
        "{}\r\nContent-Type: {}\r\nContent-Encoding: {}\r\nContent-Length: {}\r\n\r\n",
        status.as_str(),
        request.headers.content_type.unwrap_or_else(|| "Unknown".to_string()),
        "",
        request.headers.content_length.unwrap_or_else(|| "Unknown".to_string()),
    );
    stream.write_all(response.as_bytes()).unwrap();
    stream.write_all(&request.body).unwrap();
}

struct Request {
    headers: Headers,
    body: Vec<u8>,
}

#[derive(Serialize, Deserialize, Debug)]
struct Headers {
    #[serde(rename = "Start-Line")]
    start_line: String,
    #[serde(rename = "Accept-Encoding")]
    accept_encoding: Option<String>,
    #[serde(rename = "User-Agent")]
    user_agent: Option<String>,
    #[serde(rename = "Content-Type")]
    content_type: Option<String>,
    #[serde(rename = "Content-Length")]
    content_length: Option<String>,
}

impl Request {
    fn parse_start_line(&mut self) -> StartLine {
        let mut start_line: Vec<&str> = self.headers.start_line.split_whitespace().collect();

        let (_html, endpoint, verb) = (
            start_line.pop().unwrap().to_string(),
            start_line.pop().unwrap().to_string(),
            start_line.pop().unwrap(),
        );

        let verb = match verb {
            "GET" => Verb::GET,
            "POST" => Verb::POST,
            &_ => todo!(),
        };

        StartLine { verb, endpoint }
    }

    fn parse_endpoint(&mut self, dir: &str) -> StatusCode {
        let start_line = self.parse_start_line();
        self.headers.accept_encoding = Some(self.parse_encoding());

        let status = match start_line.endpoint.as_str() {
            "/" => StatusCode::_200,
            "/user-agent" => {
                let user_agent = self.headers.user_agent.clone().unwrap_or_default();
                self.body = user_agent.as_bytes().to_vec();
                StatusCode::_200
            },
            endpoint if endpoint.contains("/echo") => {
                let message = endpoint.split("/echo/").last().unwrap();
                self.body = message.as_bytes().to_vec();
                StatusCode::_200
            }
            endpoint if endpoint.contains("/files") => {
                let filename = endpoint.split("/files/").last().unwrap();
                let filepath = format!("{dir}{filename}");
                let filepath = Path::new(&filepath);

                match start_line.verb {
                    Verb::GET => {
                        let file = fs::read(filepath);
                        if let Ok(file) = file {
                            self.body = file;
                            StatusCode::_200
                        } else {
                            StatusCode::_404
                        }
                    }
                    Verb::POST => {
                        let _ = fs::write(filepath, &self.body);
                        self.headers.content_length = Some(self.body.len().to_string());
                        StatusCode::_201
                    }
                }
            }
            _ => {
                return StatusCode::_404;
            }
        };
        status
    }

    // fn handle_user_agent(&self) -> String {
    //     let user_agent = &self.headers.user_agent.clone().map_or("".to_string(), |agent| agent);
    //     let content = Content::new(user_agent.to_vec(), "text/plain", encoding);
    //     (content, StatusCode::_200)
    // }
    // //
    // fn parse_content_type(&self) -> String {
    //     let content_type = self.headers.get("Content-Type");
    //
    //     match content_type {
    //         Some(content_type) => content_type.to_string(),
    //         None => "application/octet-stream".to_string(),
    //     }
    // }
    //
    fn parse_encoding(&self) -> String {
        // let encoding = self.headers.get("Accept-Encoding");

        match &self.headers.accept_encoding {
            Some(encoding) => {
                if encoding.to_string().contains("gzip") {
                    "".to_string()
                } else {
                    "".to_string()
                }
            }
            None => "".to_string(),
        }
    }
}

enum StatusCode {
    _200,
    _404,
    _201,
}

impl StatusCode {
    fn as_str(&self) -> &'static str {
        match self {
            StatusCode::_200 => "HTTP/1.1 200 OK",
            StatusCode::_404 => "HTTP/1.1 404 Not Found",
            StatusCode::_201 => "HTTP/1.1 201 Created",
        }
    }
}

#[derive(PartialEq, Debug)]
enum Verb {
    GET,
    POST,
}

fn parse_args(args: Vec<String>) -> String {
    if args.iter().any(|arg| *arg == "--directory") {
        let dir = args.iter().last().unwrap();
        dir.to_string()
    } else {
        "".to_string()
    }
}

fn parse_request(request: &[u8]) -> Request {
    let headers: Vec<String> = request
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let headers = parse_headers(headers);
    // println!("{:?}", headers);
    let json_string = serde_json::to_string(&headers).unwrap();
    let headers: Headers = serde_json::from_str(&json_string).unwrap();
    // println!("{:?}", hmm);

    // let content_length = headers.get("Content-Length");
    let content_length = headers.content_length.clone().map_or(0, |i| i.parse::<usize>().unwrap_or(0));

    let body_start = request.len() - content_length;
    let body_end = body_start + content_length;
    let body = &request[body_start..body_end];
    let body = body.to_vec();

    Request { headers, body }
}

fn parse_headers(headers: Vec<String>) -> HashMap<String, String> {
    let mut headers_hash: HashMap<String, String> = HashMap::new();

    let (start_line, headers) = headers.split_at(1);
    headers_hash.insert("Start-Line".to_string(), start_line[0].to_string());

    for header in &headers[1..] {
        let header = header.split_once(": ");
        match header {
            Some(header) => {
                let (key, value) = header;
                headers_hash.insert(key.to_string(), value.to_string())
            }
            None => continue,
        };
    }

    headers_hash
}

struct StartLine {
    verb: Verb,
    endpoint: String,
}

// #[derive(Debug)]
// struct Content {
//     body: String,
//     content_type: String,
//     length: usize,
//     encoding: String,
// }

// impl Content {
//     fn new(body: , content_type: &str, encoding: String) -> Content {
//         let content_type = content_type.to_string();
//         let length = body.len();
//         // let encoding = encoding.to_string();
//
//         Content {
//             body,
//             content_type,
//             length,
//             encoding,
//         }
//     }
// }
